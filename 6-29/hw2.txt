
Homework #2
1.
a) condForEx1, condForEx2, condForEx3 are all false -> Output:
main begins.
a begins
main caught Ex1.
main finally.
main completes. 

b) condForEx1 is true, and condForEx2 and condForEx3 are false ->Output:
main begins
a begins
b begins
b finally
b completes
a completes
b begins
b finally
b completes
main finally
main completes.

c)condForEx1 and condForEx2 are true and condForEx3 is false.
Output:
main begins
a begins
b begins
b finally
a caught Ex2
a completes
b begins
b finally
main finally
*program terminated

d)condForEx1, and condForEx3 are true, but condForEx2 is false.
Output:
main begins
a begins
b begins
b caught ex3
b finally
b completes
a completes
b begins
b caught ex3
b finally
b completes
main finally
main completes

e) Then the method header for b() and main() should have "throws Ex2()" after the method parameter; 

Question #2:
#2 
(1a) When both chain1, and chain2 are null, it will return false. 
(1b) It will return false because when it compares the first node and its not equal, it will enter the else statement and return false.
(1c) It will return true because chain1 and chain2 will both become null after the while loop, so it ultimately returns true.
(1d) It will return false because on the last node chain1 is pointing at null while chain2 points to 44, the twos are not equal so it return false.
(1e) It will return true because chain1 and chain2 are the same, therefore ultimately will be set to null, and return true.
(1f) It will return false because the last node is different, and would enter the else statement and immediately return false.
(1g) It will return false because chain1 is not null but chain2 is null, so it won't enter either the while statement nor the if statement, it will just jump straight to return false. 
(2) This method check and see if the two chains are exactly the same, it returns true if they are, returns false otherwise. 

Question #3:
	public static <E> E findKthToLastItem(Listnode<E> head, int k) {
		if(head == null) throw new IllegalArgumengException();
		//this variable will keep count of nodes in the linked list.
		int count = 0;
		//Create a current reference that points to the same position as head
		Listnode<E> curr = head;
		//This try catch block will count all the elements in the linked list, until it refers to the last element, then it will catch the Exception, and break out of the while loop.
		try{
			while(true){
				curr = curr.getNext();
				count++;
			}
		}catch(NullPointerException e){
		}
		//This try catch block will prevent user from enter a number that is greater than the length of the linked list.
		try{
			//This conditional statement will check if the integer k that the user passed in is greater than or equal to the amount of nodes in the linked list, if so, we will create another current variable that reference to the beginning of the list.
			//Through the for loop, it will traverse through the list for count-k times. And store the value to newCurr.
			if(k>0 && k <= count){
				Listnode<E> newCurr = head;
				for(int i =0; i<count-k;i++)
					newCurr = newCurr.getNext();
				return newCurr.getData();
			}
			else throw new IndexOutOfBoundsException();
		}catch(IndexOutOfBoundsException e){
			System.out.println("Number should be between 0 and the length of the list" );
		}
		return null; 
	}

